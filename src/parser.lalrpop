use crate::syntax::*;
use crate::syntax;

grammar<'state>(ps: &'state mut ParserState);

Sp<Rule>: Spanned<Rule> = {
  <l:@L> <x:Rule> <r: @R> => Spanned::new(x, (l..r).into())
};

SepSlice1<Rule, Separator>: Vec<Rule> = {
  <start: ((<Rule> Separator)+)?> <last: Rule> => {
    match start {
      Some(mut start) => { start.push(last); start }
      None => vec![last]
    }
  }
};

pub TypeArgExpr: TypeExpr = {
  <sid:Sp<Sym>> <fields: ("." <Sp<Sym>>)*> =>
    TypeExpr::Path(sid, fields),
  <ste:Sp<TypeArgExpr>> "[" <args: SepSlice1<Sp<TypeExpr>, ",">> "]" =>
    TypeExpr::App(Box::new(ste), args),
  "fintype" => TypeExpr::FinType
}

pub TypeExpr: TypeExpr = {
  <TypeArgExpr>,
  <dom:Sp<TypeArgExpr>> "->" <codom:Sp<TypeExpr>> =>
    TypeExpr::Arrow(Box::new(dom), Box::new(codom)),
};

pub TypeDef: TypeDef = {
  "type" <name:Sp<Sym>> "=" <typ:Sp<TypeExpr>> =>
    TypeDef::new(name, vec![], TypeDefBody::Alias(typ)),
  "record" <name:Sp<Sym>> "{" <fields: (<Field> ";")*> "}" =>
    TypeDef::new(name, vec![], TypeDefBody::Record(fields)),
  "sum" <name:Sp<Sym>> "{" <variants: (<Variant> ";")*> "}" =>
     TypeDef::new(name, vec![], TypeDefBody::Sum(variants))
};

Field: Field = {
  <Sp<Sym>> ":" <Sp<TypeExpr>> => Field::new(<>)
};

Variant: Variant = {
  <name:Sp<Sym>> "{" <fields: (<Field> ";")*> "}" =>
    Variant::new(name, fields)
};

Sym: Sym = {
  r"[a-zA-Z][a-zA-Z0-9]*" => ps.intern(<>)
};

extern {
  type Error = syntax::Error;
}
